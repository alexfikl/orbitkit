# SPDX-FileCopyrightText: 2025 Alexandru Fikl <alexfikl@gmail.com>
# SPDX-License-Identifier: MIT

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable
from dataclasses import dataclass
from typing import Any, ClassVar

import orbitkit.symbolic.primitives as sym
from orbitkit.models import Model
from orbitkit.typing import Array, Scalar
from orbitkit.utils import module_logger

log = module_logger(__name__)


# {{{ code


@dataclass
class Code:
    name: str
    """An identifier for this chunk of code."""

    entrypoint: str
    """Name of the main entrypoint function."""
    source: str
    """Source code obtained from a symbolic expression."""
    inputs: tuple[sym.Variable, ...]
    """Inputs for the *source* expression."""

    # FIXME: these are sort of "default arguments" that were fished out from the
    # symbolic expression and not inlined in the *source*. There should be a less
    # hacky way to get to them? Maybe just chug them into the context?
    args: tuple[Array, ...]
    """Additional arguments required for the *source* expression."""

    context: dict[str, Any]
    """Additional context for executing the code."""

    def __str__(self) -> str:
        return self.source


@dataclass
class Assignment:
    """A symbolic ``a = b`` assignment."""

    assignee: sym.Variable
    """A variable to which the expression is assigned to."""
    rvalue: sym.Expression
    """The expression on the right-hand side of the assignment."""


# }}}

# {{{ target


def make_slice_assignments(
    y: sym.Variable, inputs: tuple[sym.Variable, ...], n: tuple[int, ...]
) -> tuple[Assignment, ...]:
    from pymbolic.primitives import Slice

    i = 0
    result: list[Assignment] = []
    for n_i, arg in zip(n, inputs, strict=True):
        result.append(Assignment(arg, y[Slice((i, i + n_i, None))]))
        i += n_i

    return tuple(result)


class Target(ABC):
    funcname: ClassVar[str]
    """The name of the generated function. This should not be seen outside of
    this code generator.
    """

    def generate_model_code(
        self,
        model: Model,
        n: int | tuple[int, ...] | None = None,
        *,
        pretty: bool = False,
    ) -> Code:
        """Generate code for a given *model*.

        :arg n: expected size of the input variables. These can all be different
            if the model takes multiple variables.
        :arg pretty: if *True*, some simple code formatting is performed.
        """
        model_n = getattr(model, "n", None)
        if n is None and model_n is None:
            raise ValueError("must provide model variable size 'n'.")

        if n is None:
            n = model_n

        if isinstance(n, int):
            n = (n,) * len(model.variables)
        assert n is not None

        if model_n is not None:
            if isinstance(model_n, int):
                model_n = (model_n,) * len(model.variables)

            if any(n_i != m_i for n_i, m_i in zip(n, model_n, strict=True)):
                raise ValueError(f"model has size {model_n} for given size {n}")

        # FIXME: all this implicitly assumes that inputs[0] is "t" and the rest
        # are the actual variables. Should make this explicit
        inputs, exprs = model.symbolify(n)
        t = sym.Variable("__t")
        y = sym.MatrixSymbol("__y", (sum(n),))

        return self.generate_code(
            (t, y),
            exprs,
            assignments=(
                Assignment(inputs[0], t),
                *make_slice_assignments(y, inputs[1:], n),
            ),
            name=type(model).__name__,
            pretty=pretty,
        )

    @abstractmethod
    def generate_code(
        self,
        inputs: sym.Variable | tuple[sym.Variable, ...],
        exprs: sym.Expression | tuple[sym.Expression, ...],
        *,
        assignments: tuple[Assignment, ...] | None = None,
        name: str = "expr",
        pretty: bool = False,
    ) -> Code:
        """Generate code for an arbitrary expression *expr*.

        :arg inputs: input arguments to the generated function entrypoint.
        :arg exprs: a set of expressions to generate code for. The resulting
            function will return an array containing all the results.

        :arg name: an identifier for the generated function.
        :arg pretty: if *True*, some simple code formatting is performed.
        """

    def lambdify_model(
        self, model: Model, n: int | tuple[int, ...] | None = None
    ) -> Callable[[float, Array], Array]:
        code = self.generate_model_code(model, n)
        return self.lambdify(code)

    @abstractmethod
    def lambdify(self, code: Code) -> Callable[..., Array]:
        """Create a callable function for some arbitrary code.

        Note that the code is assumed to be generated by this target. E.g., we
        expect there to exist a function with the name :attr:`funcname` that
        can be imported.

        .. warning::

            Like :func:`sympy.utilities.lambdify.lambdify`, this function uses
            :func:`exec` to generate a callable. This is not very safe for
            arbitrary code, so use with care!
        """


# }}}


# {{{ execute_code


_UNIQUE_CODE_COUNTER = 0


def execute_code(code: Code) -> Callable[..., Array]:
    global _UNIQUE_CODE_COUNTER  # noqa: PLW0603

    filename = f"<generated code for {code.name} [{_UNIQUE_CODE_COUNTER}]>"
    _UNIQUE_CODE_COUNTER += 1

    funclocals: dict[str, Any] = {}
    exec(
        compile(code.source, filename, "exec"),
        {**code.context, "_MODULE_SOURCE_CODE": code.source},
        funclocals,
    )

    import linecache

    func = funclocals[code.entrypoint]
    linecache.cache[filename] = (
        len(code.source),
        None,
        code.source.splitlines(keepends=True),
        filename,
    )

    import weakref

    def make_finalize(filename: str) -> Callable[[], None]:
        def _cleanup() -> None:
            if filename in linecache.cache:
                del linecache.cache[filename]

        return _cleanup

    weakref.finalize(func, make_finalize(filename))

    return func


# }}}


# {{{ lambdify


def lambdify(
    x: sym.Variable, expr: sym.Expression
) -> Callable[[Scalar | Array], Scalar | Array]:
    from orbitkit.codegen.numpy import NumpyTarget

    target = NumpyTarget()
    code = target.generate_code((x,), (expr,))
    return target.lambdify(code)


# }}}
