# SPDX-FileCopyrightText: 2025 Alexandru Fikl <alexfikl@gmail.com>
# SPDX-License-Identifier: MIT

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable
from dataclasses import dataclass
from typing import Any

import orbitkit.models.symbolic as sym
from orbitkit.typing import Array
from orbitkit.utils import module_logger

log = module_logger(__name__)


# {{{ code


@dataclass
class Code:
    name: str
    """An identifier for this chunk of code."""

    entrypoint: str
    """Name of the main entrypoint function."""
    source: str
    """Source code obtained from a symbolic expression."""
    inputs: tuple[sym.Variable, ...]
    """Inputs for the *source* expression."""

    # FIXME: these are sort of "default arguments" that were fished out from the
    # symbolic expression and not inlined in the *source*. There should be a less
    # hacky way to get to them? Maybe just chug them into the context?
    args: tuple[Array, ...]
    """Additional arguments required for the *source* expression."""

    context: dict[str, Any]
    """Additional context for executing the code."""

    def __str__(self) -> str:
        return self.source


# }}}

# {{{ target


class Target(ABC):
    def generate_model_code(
        self,
        model: sym.Model,
        n: int | tuple[int, ...] | None = None,
        *,
        pretty: bool = False,
    ) -> Code:
        """Generate code for a given *model*.

        :arg n: expected size of the input variables. These can all be different
            if the model takes multiple variables.
        :arg pretty: if *True*, some simple code formatting is performed.
        """
        model_n = getattr(model, "n", None)
        if n is None and model_n is None:
            raise ValueError("must provide model variable size 'n'.")

        if n is None:
            n = model_n

        if isinstance(n, int):
            n = (n,) * len(model.variables)
        assert n is not None

        if model_n is not None:
            if isinstance(model_n, int):
                model_n = (model_n,) * len(model.variables)

            if any(n_i != m_i for n_i, m_i in zip(n, model_n, strict=True)):
                raise ValueError(f"model has size {model_n} for given size {n}")

        inputs, exprs = model.symbolify(n)
        y = sym.MatrixSymbol("y", (sum(n),))

        return self.generate_code(
            (inputs[0], y),
            exprs,
            variables=inputs[1:],
            sizes=n,
            name=type(model).__name__,
            pretty=pretty,
        )

    @abstractmethod
    def generate_code(
        self,
        inputs: sym.Variable | tuple[sym.Variable, ...],
        exprs: sym.Expression | tuple[sym.Expression, ...],
        *,
        variables: sym.Variable | tuple[sym.Variable, ...] | None = None,
        sizes: int | tuple[int, ...] | None = None,
        name: str = "expr",
        pretty: bool = False,
    ) -> Code:
        """Generate code for an arbitrary expression *expr*.

        :arg inputs: input variables required to evaluate the expression *expr*.
        :arg name: an identifier for the generated function.
        :arg pretty: if *True*, some simple code formatting is performed.
        """

    def lambdify_model(
        self, model: sym.Model, n: int | tuple[int, ...] | None = None
    ) -> Callable[[float, Array], Array]:
        code = self.generate_model_code(model, n)
        return self.lambdify(code)

    @abstractmethod
    def lambdify(self, code: Code) -> Callable[..., Array]:
        """Create a callable function for some arbitrary code.

        Note that the code is assumed to be generated by this target. E.g., we
        expect there to exist a function with the name :attr:`funcname` that
        can be imported.

        .. warning::

            Like :func:`sympy.utilities.lambdify.lambdify`, this function uses
            :func:`exec` to generate a callable. This is not very safe for
            arbitrary code, so use with care!
        """


# }}}


# {{{ execute_code


_UNIQUE_CODE_COUNTER = 0


def execute_code(code: Code) -> Callable[..., Array]:
    global _UNIQUE_CODE_COUNTER  # noqa: PLW0603

    filename = f"<generated code for {code.name} [{_UNIQUE_CODE_COUNTER}]>"
    _UNIQUE_CODE_COUNTER += 1

    funclocals: dict[str, Any] = {}
    exec(
        compile(code.source, filename, "exec"),
        {**code.context, "_MODULE_SOURCE_CODE": code.source},
        funclocals,
    )

    import linecache

    func = funclocals[code.entrypoint]
    linecache.cache[filename] = (
        len(code.source),
        None,
        code.source.splitlines(keepends=True),
        filename,
    )

    import weakref

    def make_finalize(filename: str) -> Callable[[], None]:
        def _cleanup() -> None:
            if filename in linecache.cache:
                del linecache.cache[filename]

        return _cleanup

    weakref.finalize(func, make_finalize(filename))

    return func  # type: ignore[no-any-return]


# }}}
