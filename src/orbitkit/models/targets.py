# SPDX-FileCopyrightText: 2025 Alexandru Fikl <alexfikl@gmail.com>
# SPDX-License-Identifier: MIT

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable
from dataclasses import dataclass, field, replace
from typing import Any, ClassVar, TypeAlias

import numpy as np
from pymbolic.mapper.stringifier import PREC_NONE, StringifyMapper
from pytools import UniqueNameGenerator

import orbitkit.models.symbolic as sym
from orbitkit.typing import Array
from orbitkit.utils import module_logger

log = module_logger(__name__)


# {{{ code


@dataclass
class Code:
    name: str
    """An identifier for this chunk of code."""

    entrypoint: str
    """Name of the main entrypoint function."""
    source: str
    """Source code obtained from a symbolic expression."""
    inputs: tuple[sym.Variable, ...]
    """Inputs for the *source* expression."""

    # FIXME: these are sort of "default arguments" that were fished out from the
    # symbolic expression and not inlined in the *source*. There should be a less
    # hacky way to get to them? Maybe just chug them into the context?
    args: tuple[Array, ...]
    """Additional arguments required for the *source* expression."""

    context: dict[str, Any]
    """Additional context for executing the code."""

    def __str__(self) -> str:
        return self.source


class Target(ABC):
    def generate_model_code(
        self,
        model: sym.Model,
        n: int | tuple[int, ...] | None = None,
        *,
        pretty: bool = False,
    ) -> Code:
        """Generate code for a given *model*.

        :arg n: expected size of the input variables. These can all be different
            if the model takes multiple variables.
        :arg pretty: if *True*, some simple code formatting is performed.
        """
        model_n = getattr(model, "n", None)
        if n is None and model_n is None:
            raise ValueError("must provide model variable size 'n'.")

        if n is None:
            n = model_n

        if isinstance(n, int):
            n = (n,) * len(model.variables)
        assert n is not None

        if model_n is not None:
            if isinstance(model_n, int):
                model_n = (model_n,) * len(model.variables)

            if any(n_i != m_i for n_i, m_i in zip(n, model_n, strict=True)):
                raise ValueError(f"model has size {model_n} for given size {n}")

        inputs, exprs = model.symbolify(n)
        y = sym.MatrixSymbol("y", (sum(n),))

        return self.generate_code(
            (inputs[0], y),
            exprs,
            variables=inputs[1:],
            sizes=n,
            name=type(model).__name__,
            pretty=pretty,
        )

    @abstractmethod
    def generate_code(
        self,
        inputs: sym.Variable | tuple[sym.Variable, ...],
        exprs: sym.Expression | tuple[sym.Expression, ...],
        *,
        variables: sym.Variable | tuple[sym.Variable, ...] | None = None,
        sizes: int | tuple[int, ...] | None = None,
        name: str = "expr",
        pretty: bool = False,
    ) -> Code:
        """Generate code for an arbitrary expression *expr*.

        :arg inputs: input variables required to evaluate the expression *expr*.
        :arg name: an identifier for the generated function.
        :arg pretty: if *True*, some simple code formatting is performed.
        """

    def lambdify_model(
        self, model: sym.Model, n: int | tuple[int, ...] | None = None
    ) -> Callable[[float, Array], Array]:
        code = self.generate_model_code(model, n)
        return self.lambdify(code)

    @abstractmethod
    def lambdify(self, code: Code) -> Callable[..., Array]:
        """Create a callable function for some arbitrary code.

        Note that the code is assumed to be generated by this target. E.g., we
        expect there to exist a function with the name :attr:`funcname` that
        can be imported.

        .. warning::

            Like :func:`sympy.utilities.lambdify.lambdify`, this function uses
            :func:`exec` to generate a callable. This is not very safe for
            arbitrary code, so use with care!
        """


_UNIQUE_CODE_COUNTER = 0


def execute_code(code: Code) -> Callable[..., Array]:
    global _UNIQUE_CODE_COUNTER  # noqa: PLW0603

    filename = f"<generated code for {code.name} [{_UNIQUE_CODE_COUNTER}]>"
    _UNIQUE_CODE_COUNTER += 1

    funclocals: dict[str, Any] = {}
    exec(
        compile(code.source, filename, "exec"),
        {**code.context, "_MODULE_SOURCE_CODE": code.source},
        funclocals,
    )

    import linecache

    func = funclocals[code.entrypoint]
    linecache.cache[filename] = (
        len(code.source),
        None,
        code.source.splitlines(keepends=True),
        filename,
    )

    import weakref

    def make_finalize(filename: str) -> Callable[[], None]:
        def _cleanup() -> None:
            if filename in linecache.cache:
                del linecache.cache[filename]

        return _cleanup

    weakref.finalize(func, make_finalize(filename))

    return func  # type: ignore[no-any-return]


def lambdify(
    model: sym.Model,
    n: int | tuple[int, ...] | None = None,
    *,
    target: str = "numpy",
) -> Callable[[float, Array], Array]:
    if target == "numpy":
        ctarget = NumpyTarget()
    elif target == "jax":
        ctarget = JaxTarget()
    else:
        raise ValueError(f"unknown target: '{target}'")

    return ctarget.lambdify_model(model, n)


# }}}

# {{{ numpy target


# TODO: will need to make this into a proper compiler with statements and
# assignments and whatnot at some point. The main driving force for that is
# the need for CSE to save intermediate results..


@dataclass(frozen=True)
class NumpyCodeGenerator(StringifyMapper[Any]):
    """A code generator that stringifies a symbolic :mod:`pymbolic` expression."""

    module: str = "np"
    """Name of the :mod:`numpy` module. This can be changed for :mod:`numpy`
    compatible module with some work (e.g. from JAX).
    """
    array_arguments: dict[str, Array] = field(init=False, default_factory=dict)
    """A mapping of unique names to arrays that have been found in the expression
    graph. These need to be added as arguments or defined as variables on code
    generation.
    """
    unique_name_generator: UniqueNameGenerator = field(
        init=False,
        default_factory=lambda: UniqueNameGenerator(forced_prefix="_arg"),
    )
    """A name generator for :attr:`array_arguments`."""

    def handle_unsupported_expression(self, expr: object, enclosing_prec: int) -> str:
        raise NotImplementedError(f"{type(self)} cannot handle {type(expr)}: {expr}")

    def map_function(self, expr: sym.Function, enclosing_prec: int) -> str:
        return f"{self.module}.{expr.name}"

    def map_numpy_array(self, expr: Array, enclosing_prec: int) -> str:
        for name, ary in self.array_arguments.items():
            if ary is expr:
                return name

        name = self.unique_name_generator("")
        self.array_arguments[name] = expr

        return name

    def map_contract(self, expr: sym.Contract, enclosing_prec: int) -> str:
        aggregate = self.rec(expr.aggregate, PREC_NONE)
        return f"{self.module}.sum({aggregate}, axis={expr.axes})"

    def map_reshape(self, expr: sym.Reshape, enclosing_prec: int) -> str:
        aggregate = self.rec(expr.aggregate, PREC_NONE)
        return f"{self.module}.reshape({aggregate}, shape={expr.shape})"

    def map_dot_product(self, expr: sym.DotProduct, enclosing_prec: int) -> str:
        left = self.rec(expr.left, PREC_NONE)  # type: ignore[arg-type]
        right = self.rec(expr.right, PREC_NONE)  # type: ignore[arg-type]
        return f"{self.module}.dot({left}, {right})"


@dataclass(frozen=True)
class NumpyTarget(Target):
    module: ClassVar[str] = "np"
    """Name of the :mod:`numpy` module. This can be changed for :mod:`numpy`
    compatible module with some work (e.g. from JAX).
    """
    funcname: ClassVar[str] = "_lambdify_generated_func_numpy"
    """The name of the generated function. This should not be seen outside of
    this code generator.
    """

    def _get_module(self) -> Any:  # noqa: PLR6301
        return np

    def _get_code_generator(self) -> NumpyCodeGenerator:
        return NumpyCodeGenerator(module=self.module)

    def generate_code(
        self,
        inputs: sym.Variable | tuple[sym.Variable, ...],
        exprs: sym.Expression | tuple[sym.Expression, ...],
        *,
        variables: sym.Variable | tuple[sym.Variable, ...] | None = None,
        sizes: int | tuple[int, ...] | None = None,
        name: str = "expr",
        pretty: bool = False,
    ) -> Code:
        if isinstance(inputs, sym.Variable):
            inputs = (inputs,)

        if isinstance(exprs, sym.Expression):
            exprs = (exprs,)

        cgen = self._get_code_generator()
        expressions = ", ".join(cgen(expr) for expr in exprs)

        from pytools.py_codegen import PythonFunctionGenerator

        args = sorted(cgen.array_arguments)
        py = PythonFunctionGenerator(
            self.funcname,
            args=(*(arg.name for arg in inputs), *args),
        )

        if variables is not None:
            # FIXME: this is a bit hacky. we basically have some variables in the
            # code that we need to define beforehand based on the input vector y.
            # This seems brittle as we add more variables to the code..
            if sizes is None:
                raise ValueError("must provide variable 'sizes'")

            if isinstance(variables, sym.Variable):
                variables = (variables,)

            if isinstance(sizes, int):
                sizes = (sizes,) * len(variables)

            i = 0
            y = inputs[-1]
            for n_i, arg in zip(sizes, variables, strict=True):
                py(f"{arg.name} = {y.name}[{i}:{i + n_i}]")
                i += n_i

        if len(exprs) == 1:
            py(f"return {cgen(exprs[0])}")
        else:
            py(f"return {self.module}.hstack([{expressions}])")

        source = py.get()
        log.debug("Code:\n%s", source)

        if pretty:
            import ast

            source = ast.unparse(ast.parse(source))

        return Code(
            name=name,
            entrypoint=self.funcname,
            source=source,
            inputs=inputs,
            args=tuple(cgen.array_arguments[k] for k in args),
            context={self.module: self._get_module()},
        )

    def lambdify(self, code: Code) -> Callable[..., Array]:  # noqa: PLR6301
        func = execute_code(code)

        def wrapper(*args: Array) -> Array:
            return func(*args, *code.args)

        return wrapper


# }}}


# {{{ JaxTarget


@dataclass(frozen=True)
class JaxTarget(NumpyTarget):
    module: ClassVar[str] = "jnp"
    funcname: ClassVar[str] = "_lambdify_generated_func_jax"

    jit: bool = True
    """If *True*, the functions returned by :meth:`lambdify` will be JITed."""

    def _get_module(self) -> Any:  # noqa: PLR6301
        import jax.numpy as jnp

        return jnp

    def lambdify(self, code: Code) -> Callable[..., Array]:
        import jax

        func = execute_code(code)
        cargs = tuple(jax.device_put(arg) for arg in code.args)

        def wrapper(*args: Array) -> Array:
            return func(*args, *cargs)

        return jax.jit(wrapper)  # type: ignore[no-any-return]


# }}}
